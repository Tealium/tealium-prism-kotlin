package com.tealium.core.internal.persistence

/**
 * Constants object holding all constant values for defining all things relating to the Database
 * schema, including table names, column names, SQL that should be used to construct tables and
 * triggers.
 *
 * It also contains legacy constants as well to help support backward compatibility and migrations
 * on upgrades.
 */
object Schema {

    /**
     * The "dispatcher" table contains the entries for any dispatcher that has been registered at
     * any point during the SDK execution.
     *
     * The "id" is autogenerated
     * The "name" column is the name taken from [Module.name]
     */
    object DispatcherTable {
        const val TABLE_NAME = "dispatcher"

        const val COLUMN_ID = "id"
        const val COLUMN_NAME = "name"

        val CREATE_DISPATCHERS_TABLE = """
            CREATE TABLE IF NOT EXISTS $TABLE_NAME(
                 $COLUMN_ID     INTEGER PRIMARY KEY, 
                 $COLUMN_NAME   TEXT UNIQUE NOT NULL
            );
        """.trimIndent()
    }

    /**
     * The "dispatch" table contains the stringified version of the payload in JSON format. It also
     * stores the uuid of the [Dispatch] along with the timestamp that it was created for retrieving
     * Dispatches in a FIFO order.
     *
     * New entries inserted into this table are expected to automatically insert an entry entry in
     * the [QueueTable] for any Dispatcher in the [DispatcherTable]
     */
    object DispatchTable {
        const val TABLE_NAME = "dispatch"
        const val TRIGGER_ADD_TO_QUEUE = "dispatch_add_to_queue"

        const val COLUMN_ID = "id"
        const val COLUMN_TIMESTAMP = "timestamp"
        const val COLUMN_DISPATCH = "dispatch"

        val CREATE_DISPATCH_TABLE = """
            CREATE TABLE IF NOT EXISTS $TABLE_NAME(
                $COLUMN_ID           TEXT PRIMARY KEY, 
                $COLUMN_TIMESTAMP    LONG NOT NULL,
                $COLUMN_DISPATCH     TEXT NOT NULL
            );
        """.trimIndent()

        val CREATE_TRIGGER_ADD_TO_QUEUE = """
            CREATE TRIGGER IF NOT EXISTS $TRIGGER_ADD_TO_QUEUE 
                AFTER INSERT ON $TABLE_NAME
                FOR EACH ROW
            BEGIN 
                INSERT INTO ${QueueTable.TABLE_NAME}
                    SELECT NEW.${COLUMN_ID}, ${DispatcherTable.TABLE_NAME}.${DispatcherTable.COLUMN_ID}
                    FROM ${DispatcherTable.TABLE_NAME};
            END;
        """.trimIndent()
    }

    /**
     * The "queue" table contains only the Dispatch uuid and the id's of dispatchers in the
     * [DispatcherTable] at the time the Dispatch was added to the [DispatchTable].
     *
     * There will be an entry mapping each Dispatcher to each Dispatch, to ensure that every
     * Dispatch is process successfully by each Dispatcher before being removed from the queue.
     *
     * Once there are no relevant entries left in the "queue" for a given entry in the
     * [DispatchTable] then a [CREATE_TRIGGER_REMOVE_PROCESSED_DISPATCHES] is expected to remove it
     * automatically.
     */
    object QueueTable {
        const val TABLE_NAME = "queue"
        const val TRIGGER_REMOVE_PROCESSED_DISPATCHES = "queue_remove_processed_dispatches"

        const val COLUMN_DISPATCH_ID = "dispatch_id"
        const val COLUMN_DISPATCHER_ID = "dispatcher_id"

        val CREATE_QUEUE_TABLE = """
            CREATE TABLE IF NOT EXISTS $TABLE_NAME(
                 $COLUMN_DISPATCH_ID        TEXT, 
                 $COLUMN_DISPATCHER_ID      INTEGER,
                 PRIMARY KEY ($COLUMN_DISPATCH_ID, $COLUMN_DISPATCHER_ID),
                 FOREIGN KEY ($COLUMN_DISPATCH_ID) 
                    REFERENCES ${DispatchTable.TABLE_NAME}(${DispatchTable.COLUMN_ID})
                    ON DELETE CASCADE,
                 FOREIGN KEY ($COLUMN_DISPATCHER_ID) 
                    REFERENCES ${DispatcherTable.TABLE_NAME}(${DispatcherTable.COLUMN_ID})
                    ON DELETE CASCADE
            );
        """.trimIndent()

        val CREATE_TRIGGER_REMOVE_PROCESSED_DISPATCHES = """
            CREATE TRIGGER IF NOT EXISTS $TRIGGER_REMOVE_PROCESSED_DISPATCHES
                AFTER DELETE ON $TABLE_NAME
            BEGIN 
            	DELETE FROM ${DispatchTable.TABLE_NAME} 
            	WHERE NOT EXISTS (
            		SELECT $COLUMN_DISPATCH_ID
            	  	FROM $TABLE_NAME
            	  	WHERE $COLUMN_DISPATCH_ID = ${DispatchTable.TABLE_NAME}.${DispatchTable.COLUMN_ID}
            	);
            END;
        """.trimIndent()
    }

    /**
     * The "module" table contains the module id and name of any module that has requested to write
     * data to database.
     *
     * The "id" column is autogenerated
     * The "name" column is taken from the name property of the Module class.
     */
    object ModuleTable {
        const val TABLE_NAME = "module"

        const val COLUMN_ID = "id"
        const val COLUMN_NAME = "name"

        val CREATE_MODULE_TABLE = """
            CREATE TABLE IF NOT EXISTS $TABLE_NAME(
                 $COLUMN_ID   INTEGER PRIMARY KEY, 
                 $COLUMN_NAME TEXT UNIQUE
            );
        """.trimIndent()
    }

    /**
     * The "module_storage" table is a shared key value storage space used by any modules that
     * require basic storage functionality.
     *
     * The `module_id` column is a reference to and entry in the [ModuleTable].
     * The `key` column is the id used to store and retrieve the value
     * The `value` column is the data to be stored in String format
     * The 'expiry' column is a number describing when this data is valid for. See [Expiry]
     */
    object ModuleStorageTable {
        const val TABLE_NAME = "module_storage"

        const val COLUMN_MODULE_ID = "module_id"
        const val COLUMN_KEY = "key"
        const val COLUMN_VALUE = "value"
        const val COLUMN_EXPIRY = "expiry"

        val CREATE_MODULE_STORAGE_TABLE = """
            CREATE TABLE IF NOT EXISTS $TABLE_NAME (
                $COLUMN_MODULE_ID   INTEGER,
                $COLUMN_KEY         TEXT,
                $COLUMN_VALUE       TEXT,
                $COLUMN_EXPIRY      LONG,
            PRIMARY KEY ($COLUMN_MODULE_ID, $COLUMN_KEY),
            FOREIGN KEY ($COLUMN_MODULE_ID)
                REFERENCES ${ModuleTable.TABLE_NAME}(${ModuleTable.COLUMN_ID})
                ON DELETE CASCADE
         );
        """.trimIndent()
    }

    /**
     * This object contains all the schema constructs for versions 1 and 2 of the database. This is
     * primarily made available here to support backwards compatibility and migration of data from
     * the old schema to the new one.
     */
    object LegacyTables {
        const val DISPATCHES_TABLE_NAME = "dispatches"
        const val DATALAYER_TABLE_NAME = "datalayer"
        const val VISITORS_TABLE_NAME = "visitors"

        const val COLUMN_KEY = "key"
        const val COLUMN_VALUE = "value"
        const val COLUMN_EXPIRY = "expiry"
        const val COLUMN_TIMESTAMP = "timestamp"
        const val COLUMN_TYPE = "type"

        internal fun createLegacyTable(tableName: String): String = """
            CREATE TABLE IF NOT EXISTS $tableName (
                $COLUMN_KEY         TEXT PRIMARY KEY,
                $COLUMN_VALUE       TEXT,
                $COLUMN_EXPIRY      LONG,
                $COLUMN_TIMESTAMP   LONG,
                $COLUMN_TYPE        SMALLINT);
            """.trimIndent()
    }
}